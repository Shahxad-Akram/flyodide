/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/pyodide/pyodide.mjs":
/*!******************************************!*\
  !*** ./node_modules/pyodide/pyodide.mjs ***!
  \******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   loadPyodide: () => (/* binding */ loadPyodide),\n/* harmony export */   version: () => (/* binding */ version)\n/* harmony export */ });\nconst out = eval(\"const module={exports:{}};\\nvar __create = Object.create;\\nvar __defProp = Object.defineProperty;\\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\\nvar __getOwnPropNames = Object.getOwnPropertyNames;\\nvar __getProtoOf = Object.getPrototypeOf;\\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\\nvar __export = (target, all) => {\\n  for (var name in all)\\n    __defProp(target, name, { get: all[name], enumerable: true });\\n};\\nvar __copyProps = (to, from, except, desc) => {\\n  if (from && typeof from === \\\"object\\\" || typeof from === \\\"function\\\") {\\n    for (let key of __getOwnPropNames(from))\\n      if (!__hasOwnProp.call(to, key) && key !== except)\\n        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\\n  }\\n  return to;\\n};\\nvar __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(\\n  // If the importer is in node compatibility mode or this is not an ESM\\n  // file that has been converted to a CommonJS file using a Babel-\\n  // compatible transform (i.e. \\\"__esModule\\\" has not been set), then set\\n  // \\\"default\\\" to the CommonJS \\\"module.exports\\\" for node compatibility.\\n  isNodeMode || !mod || !mod.__esModule ? __defProp(target, \\\"default\\\", { value: mod, enumerable: true }) : target,\\n  mod\\n));\\nvar __toCommonJS = (mod) => __copyProps(__defProp({}, \\\"__esModule\\\", { value: true }), mod);\\nvar stdin_exports = {};\\n__export(stdin_exports, {\\n  loadPyodide: () => $e,\\n  version: () => M\\n});\\nmodule.exports = __toCommonJS(stdin_exports);\\nvar Q = Object.defineProperty;\\nvar s = (e, t) => Q(e, \\\"name\\\", { value: t, configurable: true }), I = ((e) => typeof require < \\\"u\\\" ? require : typeof Proxy < \\\"u\\\" ? new Proxy(e, { get: (t, o) => (typeof require < \\\"u\\\" ? require : t)[o] }) : e)(function(e) {\\n  if (typeof require < \\\"u\\\")\\n    return require.apply(this, arguments);\\n  throw new Error('Dynamic require of \\\"' + e + '\\\" is not supported');\\n});\\nfunction Z(e) {\\n  return !isNaN(parseFloat(e)) && isFinite(e);\\n}\\ns(Z, \\\"_isNumber\\\");\\nfunction E(e) {\\n  return e.charAt(0).toUpperCase() + e.substring(1);\\n}\\ns(E, \\\"_capitalize\\\");\\nfunction k(e) {\\n  return function() {\\n    return this[e];\\n  };\\n}\\ns(k, \\\"_getter\\\");\\nvar w = [\\\"isConstructor\\\", \\\"isEval\\\", \\\"isNative\\\", \\\"isToplevel\\\"], N = [\\\"columnNumber\\\", \\\"lineNumber\\\"], _ = [\\\"fileName\\\", \\\"functionName\\\", \\\"source\\\"], ee = [\\\"args\\\"], te = [\\\"evalOrigin\\\"], O = w.concat(N, _, ee, te);\\nfunction p(e) {\\n  if (e)\\n    for (var t = 0; t < O.length; t++)\\n      e[O[t]] !== void 0 && this[\\\"set\\\" + E(O[t])](e[O[t]]);\\n}\\ns(p, \\\"StackFrame\\\");\\np.prototype = { getArgs: function() {\\n  return this.args;\\n}, setArgs: function(e) {\\n  if (Object.prototype.toString.call(e) !== \\\"[object Array]\\\")\\n    throw new TypeError(\\\"Args must be an Array\\\");\\n  this.args = e;\\n}, getEvalOrigin: function() {\\n  return this.evalOrigin;\\n}, setEvalOrigin: function(e) {\\n  if (e instanceof p)\\n    this.evalOrigin = e;\\n  else if (e instanceof Object)\\n    this.evalOrigin = new p(e);\\n  else\\n    throw new TypeError(\\\"Eval Origin must be an Object or StackFrame\\\");\\n}, toString: function() {\\n  var e = this.getFileName() || \\\"\\\", t = this.getLineNumber() || \\\"\\\", o = this.getColumnNumber() || \\\"\\\", r = this.getFunctionName() || \\\"\\\";\\n  return this.getIsEval() ? e ? \\\"[eval] (\\\" + e + \\\":\\\" + t + \\\":\\\" + o + \\\")\\\" : \\\"[eval]:\\\" + t + \\\":\\\" + o : r ? r + \\\" (\\\" + e + \\\":\\\" + t + \\\":\\\" + o + \\\")\\\" : e + \\\":\\\" + t + \\\":\\\" + o;\\n} };\\np.fromString = s(function(t) {\\n  var o = t.indexOf(\\\"(\\\"), r = t.lastIndexOf(\\\")\\\"), a = t.substring(0, o), n = t.substring(o + 1, r).split(\\\",\\\"), i = t.substring(r + 1);\\n  if (i.indexOf(\\\"@\\\") === 0)\\n    var c = /@(.+?)(?::(\\\\d+))?(?::(\\\\d+))?$/.exec(i, \\\"\\\"), l = c[1], d = c[2], u = c[3];\\n  return new p({ functionName: a, args: n || void 0, fileName: l, lineNumber: d || void 0, columnNumber: u || void 0 });\\n}, \\\"StackFrame$$fromString\\\");\\nfor (b = 0; b < w.length; b++)\\n  p.prototype[\\\"get\\\" + E(w[b])] = k(w[b]), p.prototype[\\\"set\\\" + E(w[b])] = /* @__PURE__ */ function(e) {\\n    return function(t) {\\n      this[e] = !!t;\\n    };\\n  }(w[b]);\\nvar b;\\nfor (v = 0; v < N.length; v++)\\n  p.prototype[\\\"get\\\" + E(N[v])] = k(N[v]), p.prototype[\\\"set\\\" + E(N[v])] = /* @__PURE__ */ function(e) {\\n    return function(t) {\\n      if (!Z(t))\\n        throw new TypeError(e + \\\" must be a Number\\\");\\n      this[e] = Number(t);\\n    };\\n  }(N[v]);\\nvar v;\\nfor (h = 0; h < _.length; h++)\\n  p.prototype[\\\"get\\\" + E(_[h])] = k(_[h]), p.prototype[\\\"set\\\" + E(_[h])] = /* @__PURE__ */ function(e) {\\n    return function(t) {\\n      this[e] = String(t);\\n    };\\n  }(_[h]);\\nvar h, x = p;\\nfunction ne() {\\n  var e = /^\\\\s*at .*(\\\\S+:\\\\d+|\\\\(native\\\\))/m, t = /^(eval@)?(\\\\[native code])?$/;\\n  return { parse: s(function(r) {\\n    if (r.stack && r.stack.match(e))\\n      return this.parseV8OrIE(r);\\n    if (r.stack)\\n      return this.parseFFOrSafari(r);\\n    throw new Error(\\\"Cannot parse given Error object\\\");\\n  }, \\\"ErrorStackParser$$parse\\\"), extractLocation: s(function(r) {\\n    if (r.indexOf(\\\":\\\") === -1)\\n      return [r];\\n    var a = /(.+?)(?::(\\\\d+))?(?::(\\\\d+))?$/, n = a.exec(r.replace(/[()]/g, \\\"\\\"));\\n    return [n[1], n[2] || void 0, n[3] || void 0];\\n  }, \\\"ErrorStackParser$$extractLocation\\\"), parseV8OrIE: s(function(r) {\\n    var a = r.stack.split(`\\n`).filter(function(n) {\\n      return !!n.match(e);\\n    }, this);\\n    return a.map(function(n) {\\n      n.indexOf(\\\"(eval \\\") > -1 && (n = n.replace(/eval code/g, \\\"eval\\\").replace(/(\\\\(eval at [^()]*)|(,.*$)/g, \\\"\\\"));\\n      var i = n.replace(/^\\\\s+/, \\\"\\\").replace(/\\\\(eval code/g, \\\"(\\\").replace(/^.*?\\\\s+/, \\\"\\\"), c = i.match(/ (\\\\(.+\\\\)$)/);\\n      i = c ? i.replace(c[0], \\\"\\\") : i;\\n      var l = this.extractLocation(c ? c[1] : i), d = c && i || void 0, u = [\\\"eval\\\", \\\"<anonymous>\\\"].indexOf(l[0]) > -1 ? void 0 : l[0];\\n      return new x({ functionName: d, fileName: u, lineNumber: l[1], columnNumber: l[2], source: n });\\n    }, this);\\n  }, \\\"ErrorStackParser$$parseV8OrIE\\\"), parseFFOrSafari: s(function(r) {\\n    var a = r.stack.split(`\\n`).filter(function(n) {\\n      return !n.match(t);\\n    }, this);\\n    return a.map(function(n) {\\n      if (n.indexOf(\\\" > eval\\\") > -1 && (n = n.replace(/ line (\\\\d+)(?: > eval line \\\\d+)* > eval:\\\\d+:\\\\d+/g, \\\":$1\\\")), n.indexOf(\\\"@\\\") === -1 && n.indexOf(\\\":\\\") === -1)\\n        return new x({ functionName: n });\\n      var i = /((.*\\\".+\\\"[^@]*)?[^@]*)(?:@)/, c = n.match(i), l = c && c[1] ? c[1] : void 0, d = this.extractLocation(n.replace(i, \\\"\\\"));\\n      return new x({ functionName: l, fileName: d[0], lineNumber: d[1], columnNumber: d[2], source: n });\\n    }, this);\\n  }, \\\"ErrorStackParser$$parseFFOrSafari\\\") };\\n}\\ns(ne, \\\"ErrorStackParser\\\");\\nvar re = new ne();\\nvar C = re;\\nvar g = typeof process == \\\"object\\\" && typeof process.versions == \\\"object\\\" && typeof process.versions.node == \\\"string\\\" && !process.browser, A = g && typeof module < \\\"u\\\" && typeof module.exports < \\\"u\\\" && typeof I < \\\"u\\\" && typeof __dirname < \\\"u\\\", W = g && !A, Ne = typeof globalThis.Bun < \\\"u\\\", ie = typeof Deno < \\\"u\\\", B = !g && !ie, $ = B && typeof window == \\\"object\\\" && typeof document == \\\"object\\\" && typeof document.createElement == \\\"function\\\" && \\\"sessionStorage\\\" in window && typeof importScripts != \\\"function\\\", j = B && typeof importScripts == \\\"function\\\" && typeof self == \\\"object\\\", _e = typeof navigator == \\\"object\\\" && typeof navigator.userAgent == \\\"string\\\" && navigator.userAgent.indexOf(\\\"Chrome\\\") == -1 && navigator.userAgent.indexOf(\\\"Safari\\\") > -1;\\nvar z, D, V, H, L;\\nasync function T() {\\n  if (!g || (z = (await import(\\\"node:url\\\")).default, H = await import(\\\"node:fs\\\"), L = await import(\\\"node:fs/promises\\\"), V = (await import(\\\"node:vm\\\")).default, D = await import(\\\"node:path\\\"), U = D.sep, typeof I < \\\"u\\\"))\\n    return;\\n  let e = H, t = await import(\\\"node:crypto\\\"), o = await import(\\\"ws\\\"), r = await import(\\\"node:child_process\\\"), a = { fs: e, crypto: t, ws: o, child_process: r };\\n  ({});\\n}\\ns(T, \\\"initNodeModules\\\");\\nfunction oe(e, t) {\\n  return D.resolve(t || \\\".\\\", e);\\n}\\ns(oe, \\\"node_resolvePath\\\");\\nfunction ae(e, t) {\\n  return t === void 0 && (t = location), new URL(e, t).toString();\\n}\\ns(ae, \\\"browser_resolvePath\\\");\\nvar P;\\ng ? P = oe : P = ae;\\nvar U;\\ng || (U = \\\"/\\\");\\nfunction se(e, t) {\\n  return e.startsWith(\\\"file://\\\") && (e = e.slice(7)), e.includes(\\\"://\\\") ? { response: fetch(e) } : { binary: L.readFile(e).then((o) => new Uint8Array(o.buffer, o.byteOffset, o.byteLength)) };\\n}\\ns(se, \\\"node_getBinaryResponse\\\");\\nfunction ce(e, t) {\\n  let o = new URL(e, location);\\n  return { response: fetch(o, t ? { integrity: t } : {}) };\\n}\\ns(ce, \\\"browser_getBinaryResponse\\\");\\nvar F;\\ng ? F = se : F = ce;\\nasync function q(e, t) {\\n  let { response: o, binary: r } = F(e, t);\\n  if (r)\\n    return r;\\n  let a = await o;\\n  if (!a.ok)\\n    throw new Error(`Failed to load '${e}': request failed.`);\\n  return new Uint8Array(await a.arrayBuffer());\\n}\\ns(q, \\\"loadBinaryFile\\\");\\nvar R;\\nif ($)\\n  R = s(async (e) => await import(e), \\\"loadScript\\\");\\nelse if (j)\\n  R = s(async (e) => {\\n    try {\\n      globalThis.importScripts(e);\\n    } catch (t) {\\n      if (t instanceof TypeError)\\n        await import(e);\\n      else\\n        throw t;\\n    }\\n  }, \\\"loadScript\\\");\\nelse if (g)\\n  R = le;\\nelse\\n  throw new Error(\\\"Cannot determine runtime environment\\\");\\nasync function le(e) {\\n  e.startsWith(\\\"file://\\\") && (e = e.slice(7)), e.includes(\\\"://\\\") ? V.runInThisContext(await (await fetch(e)).text()) : await import(z.pathToFileURL(e).href);\\n}\\ns(le, \\\"nodeLoadScript\\\");\\nasync function J(e) {\\n  if (g) {\\n    await T();\\n    let t = await L.readFile(e, { encoding: \\\"utf8\\\" });\\n    return JSON.parse(t);\\n  } else\\n    return await (await fetch(e)).json();\\n}\\ns(J, \\\"loadLockFile\\\");\\nasync function K() {\\n  if (A)\\n    return __dirname;\\n  let e;\\n  try {\\n    throw new Error();\\n  } catch (r) {\\n    e = r;\\n  }\\n  let t = C.parse(e)[0].fileName;\\n  if (g && !t.startsWith(\\\"file://\\\") && (t = `file://${t}`), W) {\\n    let r = await import(\\\"node:path\\\");\\n    return (await import(\\\"node:url\\\")).fileURLToPath(r.dirname(t));\\n  }\\n  let o = t.lastIndexOf(U);\\n  if (o === -1)\\n    throw new Error(\\\"Could not extract indexURL path from pyodide module location\\\");\\n  return t.slice(0, o);\\n}\\ns(K, \\\"calculateDirname\\\");\\nfunction Y(e) {\\n  let t = e.FS, o = e.FS.filesystems.MEMFS, r = e.PATH, a = { DIR_MODE: 16895, FILE_MODE: 33279, mount: function(n) {\\n    if (!n.opts.fileSystemHandle)\\n      throw new Error(\\\"opts.fileSystemHandle is required\\\");\\n    return o.mount.apply(null, arguments);\\n  }, syncfs: async (n, i, c) => {\\n    try {\\n      let l = a.getLocalSet(n), d = await a.getRemoteSet(n), u = i ? d : l, m = i ? l : d;\\n      await a.reconcile(n, u, m), c(null);\\n    } catch (l) {\\n      c(l);\\n    }\\n  }, getLocalSet: (n) => {\\n    let i = /* @__PURE__ */ Object.create(null);\\n    function c(u) {\\n      return u !== \\\".\\\" && u !== \\\"..\\\";\\n    }\\n    s(c, \\\"isRealDir\\\");\\n    function l(u) {\\n      return (m) => r.join2(u, m);\\n    }\\n    s(l, \\\"toAbsolute\\\");\\n    let d = t.readdir(n.mountpoint).filter(c).map(l(n.mountpoint));\\n    for (; d.length; ) {\\n      let u = d.pop(), m = t.stat(u);\\n      t.isDir(m.mode) && d.push.apply(d, t.readdir(u).filter(c).map(l(u))), i[u] = { timestamp: m.mtime, mode: m.mode };\\n    }\\n    return { type: \\\"local\\\", entries: i };\\n  }, getRemoteSet: async (n) => {\\n    let i = /* @__PURE__ */ Object.create(null), c = await de(n.opts.fileSystemHandle);\\n    for (let [l, d] of c)\\n      l !== \\\".\\\" && (i[r.join2(n.mountpoint, l)] = { timestamp: d.kind === \\\"file\\\" ? new Date((await d.getFile()).lastModified) : /* @__PURE__ */ new Date(), mode: d.kind === \\\"file\\\" ? a.FILE_MODE : a.DIR_MODE });\\n    return { type: \\\"remote\\\", entries: i, handles: c };\\n  }, loadLocalEntry: (n) => {\\n    let c = t.lookupPath(n).node, l = t.stat(n);\\n    if (t.isDir(l.mode))\\n      return { timestamp: l.mtime, mode: l.mode };\\n    if (t.isFile(l.mode))\\n      return c.contents = o.getFileDataAsTypedArray(c), { timestamp: l.mtime, mode: l.mode, contents: c.contents };\\n    throw new Error(\\\"node type not supported\\\");\\n  }, storeLocalEntry: (n, i) => {\\n    if (t.isDir(i.mode))\\n      t.mkdirTree(n, i.mode);\\n    else if (t.isFile(i.mode))\\n      t.writeFile(n, i.contents, { canOwn: true });\\n    else\\n      throw new Error(\\\"node type not supported\\\");\\n    t.chmod(n, i.mode), t.utime(n, i.timestamp, i.timestamp);\\n  }, removeLocalEntry: (n) => {\\n    var i = t.stat(n);\\n    t.isDir(i.mode) ? t.rmdir(n) : t.isFile(i.mode) && t.unlink(n);\\n  }, loadRemoteEntry: async (n) => {\\n    if (n.kind === \\\"file\\\") {\\n      let i = await n.getFile();\\n      return { contents: new Uint8Array(await i.arrayBuffer()), mode: a.FILE_MODE, timestamp: new Date(i.lastModified) };\\n    } else {\\n      if (n.kind === \\\"directory\\\")\\n        return { mode: a.DIR_MODE, timestamp: /* @__PURE__ */ new Date() };\\n      throw new Error(\\\"unknown kind: \\\" + n.kind);\\n    }\\n  }, storeRemoteEntry: async (n, i, c) => {\\n    let l = n.get(r.dirname(i)), d = t.isFile(c.mode) ? await l.getFileHandle(r.basename(i), { create: true }) : await l.getDirectoryHandle(r.basename(i), { create: true });\\n    if (d.kind === \\\"file\\\") {\\n      let u = await d.createWritable();\\n      await u.write(c.contents), await u.close();\\n    }\\n    n.set(i, d);\\n  }, removeRemoteEntry: async (n, i) => {\\n    await n.get(r.dirname(i)).removeEntry(r.basename(i)), n.delete(i);\\n  }, reconcile: async (n, i, c) => {\\n    let l = 0, d = [];\\n    Object.keys(i.entries).forEach(function(f) {\\n      let y = i.entries[f], S = c.entries[f];\\n      (!S || t.isFile(y.mode) && y.timestamp.getTime() > S.timestamp.getTime()) && (d.push(f), l++);\\n    }), d.sort();\\n    let u = [];\\n    if (Object.keys(c.entries).forEach(function(f) {\\n      i.entries[f] || (u.push(f), l++);\\n    }), u.sort().reverse(), !l)\\n      return;\\n    let m = i.type === \\\"remote\\\" ? i.handles : c.handles;\\n    for (let f of d) {\\n      let y = r.normalize(f.replace(n.mountpoint, \\\"/\\\")).substring(1);\\n      if (c.type === \\\"local\\\") {\\n        let S = m.get(y), X = await a.loadRemoteEntry(S);\\n        a.storeLocalEntry(f, X);\\n      } else {\\n        let S = a.loadLocalEntry(f);\\n        await a.storeRemoteEntry(m, y, S);\\n      }\\n    }\\n    for (let f of u)\\n      if (c.type === \\\"local\\\")\\n        a.removeLocalEntry(f);\\n      else {\\n        let y = r.normalize(f.replace(n.mountpoint, \\\"/\\\")).substring(1);\\n        await a.removeRemoteEntry(m, y);\\n      }\\n  } };\\n  e.FS.filesystems.NATIVEFS_ASYNC = a;\\n}\\ns(Y, \\\"initializeNativeFS\\\");\\nvar de = s(async (e) => {\\n  let t = [];\\n  async function o(a) {\\n    for await (let n of a.values())\\n      t.push(n), n.kind === \\\"directory\\\" && await o(n);\\n  }\\n  s(o, \\\"collect\\\"), await o(e);\\n  let r = /* @__PURE__ */ new Map();\\n  r.set(\\\".\\\", e);\\n  for (let a of t) {\\n    let n = (await e.resolve(a)).join(\\\"/\\\");\\n    r.set(n, a);\\n  }\\n  return r;\\n}, \\\"getFsHandles\\\");\\nfunction G(e) {\\n  let t = { noImageDecoding: true, noAudioDecoding: true, noWasmDecoding: false, preRun: ge(e), quit(o, r) {\\n    throw t.exited = { status: o, toThrow: r }, r;\\n  }, print: e.stdout, printErr: e.stderr, thisProgram: e._sysExecutable, arguments: e.args, API: { config: e }, locateFile: (o) => e.indexURL + o, instantiateWasm: ye(e.indexURL) };\\n  return t;\\n}\\ns(G, \\\"createSettings\\\");\\nfunction ue(e) {\\n  return function(t) {\\n    let o = \\\"/\\\";\\n    try {\\n      t.FS.mkdirTree(e);\\n    } catch (r) {\\n      console.error(`Error occurred while making a home directory '${e}':`), console.error(r), console.error(`Using '${o}' for a home directory instead`), e = o;\\n    }\\n    t.FS.chdir(e);\\n  };\\n}\\ns(ue, \\\"createHomeDirectory\\\");\\nfunction fe(e) {\\n  return function(t) {\\n    Object.assign(t.ENV, e);\\n  };\\n}\\ns(fe, \\\"setEnvironment\\\");\\nfunction me(e) {\\n  return (t) => {\\n    for (let o of e)\\n      t.FS.mkdirTree(o), t.FS.mount(t.FS.filesystems.NODEFS, { root: o }, o);\\n  };\\n}\\ns(me, \\\"mountLocalDirectories\\\");\\nfunction pe(e) {\\n  let t = q(e);\\n  return (o) => {\\n    let r = o._py_version_major(), a = o._py_version_minor();\\n    o.FS.mkdirTree(\\\"/lib\\\"), o.FS.mkdirTree(`/lib/python${r}.${a}/site-packages`), o.addRunDependency(\\\"install-stdlib\\\"), t.then((n) => {\\n      o.FS.writeFile(`/lib/python${r}${a}.zip`, n);\\n    }).catch((n) => {\\n      console.error(\\\"Error occurred while installing the standard library:\\\"), console.error(n);\\n    }).finally(() => {\\n      o.removeRunDependency(\\\"install-stdlib\\\");\\n    });\\n  };\\n}\\ns(pe, \\\"installStdlib\\\");\\nfunction ge(e) {\\n  let t;\\n  return e.stdLibURL != null ? t = e.stdLibURL : t = e.indexURL + \\\"python_stdlib.zip\\\", [pe(t), ue(e.env.HOME), fe(e.env), me(e._node_mounts), Y];\\n}\\ns(ge, \\\"getFileSystemInitializationFuncs\\\");\\nfunction ye(e) {\\n  if (typeof WasmOffsetConverter < \\\"u\\\")\\n    return;\\n  let { binary: t, response: o } = F(e + \\\"pyodide.asm.wasm\\\");\\n  return function(r, a) {\\n    return async function() {\\n      try {\\n        let n;\\n        o ? n = await WebAssembly.instantiateStreaming(o, r) : n = await WebAssembly.instantiate(await t, r);\\n        let { instance: i, module: c } = n;\\n        a(i, c);\\n      } catch (n) {\\n        console.warn(\\\"wasm instantiation failed!\\\"), console.warn(n);\\n      }\\n    }(), {};\\n  };\\n}\\ns(ye, \\\"getInstantiateWasmFunc\\\");\\nvar M = \\\"0.27.4\\\";\\nasync function $e(e = {}) {\\n  var u, m;\\n  await T();\\n  let t = e.indexURL || await K();\\n  t = P(t), t.endsWith(\\\"/\\\") || (t += \\\"/\\\"), e.indexURL = t;\\n  let o = { fullStdLib: false, jsglobals: globalThis, stdin: globalThis.prompt ? globalThis.prompt : void 0, lockFileURL: t + \\\"pyodide-lock.json\\\", args: [], _node_mounts: [], env: {}, packageCacheDir: t, packages: [], enableRunUntilComplete: false, checkAPIVersion: true, BUILD_ID: \\\"3688f170b8197d889daf1db299085c5cad369a4656ca9c57fbe1f8cdcc4c7cd3\\\" }, r = Object.assign(o, e);\\n  (u = r.env).HOME ?? (u.HOME = \\\"/home/pyodide\\\"), (m = r.env).PYTHONINSPECT ?? (m.PYTHONINSPECT = \\\"1\\\");\\n  let a = G(r), n = a.API;\\n  if (n.lockFilePromise = J(r.lockFileURL), typeof _createPyodideModule != \\\"function\\\") {\\n    let f = `${r.indexURL}pyodide.asm.js`;\\n    await R(f);\\n  }\\n  let i;\\n  if (e._loadSnapshot) {\\n    let f = await e._loadSnapshot;\\n    ArrayBuffer.isView(f) ? i = f : i = new Uint8Array(f), a.noInitialRun = true, a.INITIAL_MEMORY = i.length;\\n  }\\n  let c = await _createPyodideModule(a);\\n  if (a.exited)\\n    throw a.exited.toThrow;\\n  if (e.pyproxyToStringRepr && n.setPyProxyToStringMethod(true), n.version !== M && r.checkAPIVersion)\\n    throw new Error(`Pyodide version does not match: '${M}' <==> '${n.version}'. If you updated the Pyodide version, make sure you also updated the 'indexURL' parameter passed to loadPyodide.`);\\n  c.locateFile = (f) => {\\n    throw new Error(\\\"Didn't expect to load any more file_packager files!\\\");\\n  };\\n  let l;\\n  i && (l = n.restoreSnapshot(i));\\n  let d = n.finalizeBootstrap(l, e._snapshotDeserializer);\\n  return n.sys.path.insert(0, n.config.env.HOME), d.version.includes(\\\"dev\\\") || n.setCdnUrl(`https://cdn.jsdelivr.net/pyodide/v${d.version}/full/`), n._pyodide.set_excepthook(), await n.packageIndexReady, n.initializeStreams(r.stdin, r.stdout, r.stderr), d;\\n}\\ns($e, \\\"loadPyodide\\\");\\nmodule.exports;\\n\");\nconst loadPyodide = out.loadPyodide;\nconst version = out.version;\n\n//# sourceURL=webpack://lib_ts/./node_modules/pyodide/pyodide.mjs?");

/***/ }),

/***/ "./src/index.ts":
/*!**********************!*\
  !*** ./src/index.ts ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var pyodide__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! pyodide */ \"./node_modules/pyodide/pyodide.mjs\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _regeneratorRuntime() { \"use strict\"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return e; }; var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function (t, e, r) { t[e] = r.value; }, i = \"function\" == typeof Symbol ? Symbol : {}, a = i.iterator || \"@@iterator\", c = i.asyncIterator || \"@@asyncIterator\", u = i.toStringTag || \"@@toStringTag\"; function define(t, e, r) { return Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }), t[e]; } try { define({}, \"\"); } catch (t) { define = function define(t, e, r) { return t[e] = r; }; } function wrap(t, e, r, n) { var i = e && e.prototype instanceof Generator ? e : Generator, a = Object.create(i.prototype), c = new Context(n || []); return o(a, \"_invoke\", { value: makeInvokeMethod(t, r, c) }), a; } function tryCatch(t, e, r) { try { return { type: \"normal\", arg: t.call(e, r) }; } catch (t) { return { type: \"throw\", arg: t }; } } e.wrap = wrap; var h = \"suspendedStart\", l = \"suspendedYield\", f = \"executing\", s = \"completed\", y = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var p = {}; define(p, a, function () { return this; }); var d = Object.getPrototypeOf, v = d && d(d(values([]))); v && v !== r && n.call(v, a) && (p = v); var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p); function defineIteratorMethods(t) { [\"next\", \"throw\", \"return\"].forEach(function (e) { define(t, e, function (t) { return this._invoke(e, t); }); }); } function AsyncIterator(t, e) { function invoke(r, o, i, a) { var c = tryCatch(t[r], t, o); if (\"throw\" !== c.type) { var u = c.arg, h = u.value; return h && \"object\" == _typeof(h) && n.call(h, \"__await\") ? e.resolve(h.__await).then(function (t) { invoke(\"next\", t, i, a); }, function (t) { invoke(\"throw\", t, i, a); }) : e.resolve(h).then(function (t) { u.value = t, i(u); }, function (t) { return invoke(\"throw\", t, i, a); }); } a(c.arg); } var r; o(this, \"_invoke\", { value: function value(t, n) { function callInvokeWithMethodAndArg() { return new e(function (e, r) { invoke(t, n, e, r); }); } return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(e, r, n) { var o = h; return function (i, a) { if (o === f) throw Error(\"Generator is already running\"); if (o === s) { if (\"throw\" === i) throw a; return { value: t, done: !0 }; } for (n.method = i, n.arg = a;;) { var c = n.delegate; if (c) { var u = maybeInvokeDelegate(c, n); if (u) { if (u === y) continue; return u; } } if (\"next\" === n.method) n.sent = n._sent = n.arg;else if (\"throw\" === n.method) { if (o === h) throw o = s, n.arg; n.dispatchException(n.arg); } else \"return\" === n.method && n.abrupt(\"return\", n.arg); o = f; var p = tryCatch(e, r, n); if (\"normal\" === p.type) { if (o = n.done ? s : l, p.arg === y) continue; return { value: p.arg, done: n.done }; } \"throw\" === p.type && (o = s, n.method = \"throw\", n.arg = p.arg); } }; } function maybeInvokeDelegate(e, r) { var n = r.method, o = e.iterator[n]; if (o === t) return r.delegate = null, \"throw\" === n && e.iterator[\"return\"] && (r.method = \"return\", r.arg = t, maybeInvokeDelegate(e, r), \"throw\" === r.method) || \"return\" !== n && (r.method = \"throw\", r.arg = new TypeError(\"The iterator does not provide a '\" + n + \"' method\")), y; var i = tryCatch(o, e.iterator, r.arg); if (\"throw\" === i.type) return r.method = \"throw\", r.arg = i.arg, r.delegate = null, y; var a = i.arg; return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, \"return\" !== r.method && (r.method = \"next\", r.arg = t), r.delegate = null, y) : a : (r.method = \"throw\", r.arg = new TypeError(\"iterator result is not an object\"), r.delegate = null, y); } function pushTryEntry(t) { var e = { tryLoc: t[0] }; 1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e); } function resetTryEntry(t) { var e = t.completion || {}; e.type = \"normal\", delete e.arg, t.completion = e; } function Context(t) { this.tryEntries = [{ tryLoc: \"root\" }], t.forEach(pushTryEntry, this), this.reset(!0); } function values(e) { if (e || \"\" === e) { var r = e[a]; if (r) return r.call(e); if (\"function\" == typeof e.next) return e; if (!isNaN(e.length)) { var o = -1, i = function next() { for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next; return next.value = t, next.done = !0, next; }; return i.next = i; } } throw new TypeError(_typeof(e) + \" is not iterable\"); } return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, \"constructor\", { value: GeneratorFunctionPrototype, configurable: !0 }), o(GeneratorFunctionPrototype, \"constructor\", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, \"GeneratorFunction\"), e.isGeneratorFunction = function (t) { var e = \"function\" == typeof t && t.constructor; return !!e && (e === GeneratorFunction || \"GeneratorFunction\" === (e.displayName || e.name)); }, e.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, \"GeneratorFunction\")), t.prototype = Object.create(g), t; }, e.awrap = function (t) { return { __await: t }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () { return this; }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) { void 0 === i && (i = Promise); var a = new AsyncIterator(wrap(t, r, n, o), i); return e.isGeneratorFunction(r) ? a : a.next().then(function (t) { return t.done ? t.value : a.next(); }); }, defineIteratorMethods(g), define(g, u, \"Generator\"), define(g, a, function () { return this; }), define(g, \"toString\", function () { return \"[object Generator]\"; }), e.keys = function (t) { var e = Object(t), r = []; for (var n in e) r.push(n); return r.reverse(), function next() { for (; r.length;) { var t = r.pop(); if (t in e) return next.value = t, next.done = !1, next; } return next.done = !0, next; }; }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e) { if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = \"next\", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) \"t\" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t); }, stop: function stop() { this.done = !0; var t = this.tryEntries[0].completion; if (\"throw\" === t.type) throw t.arg; return this.rval; }, dispatchException: function dispatchException(e) { if (this.done) throw e; var r = this; function handle(n, o) { return a.type = \"throw\", a.arg = e, r.next = n, o && (r.method = \"next\", r.arg = t), !!o; } for (var o = this.tryEntries.length - 1; o >= 0; --o) { var i = this.tryEntries[o], a = i.completion; if (\"root\" === i.tryLoc) return handle(\"end\"); if (i.tryLoc <= this.prev) { var c = n.call(i, \"catchLoc\"), u = n.call(i, \"finallyLoc\"); if (c && u) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } else if (c) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); } else { if (!u) throw Error(\"try statement without catch or finally\"); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } } } }, abrupt: function abrupt(t, e) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var o = this.tryEntries[r]; if (o.tryLoc <= this.prev && n.call(o, \"finallyLoc\") && this.prev < o.finallyLoc) { var i = o; break; } } i && (\"break\" === t || \"continue\" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null); var a = i ? i.completion : {}; return a.type = t, a.arg = e, i ? (this.method = \"next\", this.next = i.finallyLoc, y) : this.complete(a); }, complete: function complete(t, e) { if (\"throw\" === t.type) throw t.arg; return \"break\" === t.type || \"continue\" === t.type ? this.next = t.arg : \"return\" === t.type ? (this.rval = this.arg = t.arg, this.method = \"return\", this.next = \"end\") : \"normal\" === t.type && e && (this.next = e), y; }, finish: function finish(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y; } }, \"catch\": function _catch(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.tryLoc === t) { var n = r.completion; if (\"throw\" === n.type) { var o = n.arg; resetTryEntry(r); } return o; } } throw Error(\"illegal catch attempt\"); }, delegateYield: function delegateYield(e, r, n) { return this.delegate = { iterator: values(e), resultName: r, nextLoc: n }, \"next\" === this.method && (this.arg = t), y; } }, e; }\nfunction asyncGeneratorStep(n, t, e, r, o, a, c) { try { var i = n[a](c), u = i.value; } catch (n) { return void e(n); } i.done ? t(u) : Promise.resolve(u).then(r, o); }\nfunction _asyncToGenerator(n) { return function () { var t = this, e = arguments; return new Promise(function (r, o) { var a = n.apply(t, e); function _next(n) { asyncGeneratorStep(a, r, o, _next, _throw, \"next\", n); } function _throw(n) { asyncGeneratorStep(a, r, o, _next, _throw, \"throw\", n); } _next(void 0); }); }; }\n\nvar pyodide;\nfunction initPyodide(_x) {\n  return _initPyodide.apply(this, arguments);\n}\nfunction _initPyodide() {\n  _initPyodide = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee(indexURL) {\n    return _regeneratorRuntime().wrap(function _callee$(_context) {\n      while (1) switch (_context.prev = _context.next) {\n        case 0:\n          _context.prev = 0;\n          _context.next = 3;\n          return (0,pyodide__WEBPACK_IMPORTED_MODULE_0__.loadPyodide)({\n            indexURL: indexURL,\n            packages: [\"numpy\"],\n            stdout: function stdout(std_out) {\n              channelMessageHandler(window.PythonOutputCallback, std_out);\n            }\n          });\n        case 3:\n          pyodide = _context.sent;\n          channelMessageHandler(window.PyodideLoadedCallback, \"Pyodide loaded successfully...!\");\n          _context.next = 10;\n          break;\n        case 7:\n          _context.prev = 7;\n          _context.t0 = _context[\"catch\"](0);\n          channelMessageHandler(window.PyodideErrorCallback, \"***Error loading Pyodide***, \" + _context.t0);\n        case 10:\n        case \"end\":\n          return _context.stop();\n      }\n    }, _callee, null, [[0, 7]]);\n  }));\n  return _initPyodide.apply(this, arguments);\n}\nfunction executePythonCode(_x2) {\n  return _executePythonCode.apply(this, arguments);\n}\nfunction _executePythonCode() {\n  _executePythonCode = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee2(code) {\n    var codeReturn, pyError;\n    return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n      while (1) switch (_context2.prev = _context2.next) {\n        case 0:\n          _context2.prev = 0;\n          _context2.next = 3;\n          return pyodide.loadPackagesFromImports(code);\n        case 3:\n          _context2.next = 5;\n          return pyodide.runPythonAsync(code);\n        case 5:\n          codeReturn = _context2.sent;\n          if (codeReturn !== undefined) {\n            channelMessageHandler(window.PythonReturnCallback, JSON.stringify(codeReturn.toJs()));\n          }\n          _context2.next = 13;\n          break;\n        case 9:\n          _context2.prev = 9;\n          _context2.t0 = _context2[\"catch\"](0);\n          pyError = pyodide.runPython(\"\\n            from traceback import format_exception\\n            import sys\\n            \\\"\\\".join(\\n                format_exception(sys.last_type, sys.last_value, sys.last_traceback)\\n            )\\n        \");\n          channelMessageHandler(window.PythonErrorCallback, pyError);\n        case 13:\n        case \"end\":\n          return _context2.stop();\n      }\n    }, _callee2, null, [[0, 9]]);\n  }));\n  return _executePythonCode.apply(this, arguments);\n}\nfunction channelMessageHandler(channel, message) {\n  if (channel) {\n    channel.postMessage(message);\n  } else {\n    console.log(message);\n  }\n}\nwindow.initPyodide = initPyodide;\nwindow.executePythonCode = executePythonCode;\n\n//# sourceURL=webpack://lib_ts/./src/index.ts?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/index.ts");
/******/ 	
/******/ })()
;